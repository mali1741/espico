
// include this for ODROID-GO
// #include <odroid_go.h>

#include <Ticker.h>
#include <SPI.h>
#include <FS.h>
#include "keys.h"

#ifdef _ODROID_GO_H_

#include <SPIFFS.h>
ILI9341& tft = GO.lcd;
TaskHandle_t cpuTaskHandle;
TaskHandle_t soundTaskHandle;
TaskHandle_t infoTaskHandle;
TaskHandle_t screenTaskHandle;
SemaphoreHandle_t screenMutex;
SemaphoreHandle_t usingDrawBuffer;

#define COOS_DELAY(d) vTaskDelay(pdMS_TO_TICKS(d))
#define COOS_TASK_PARAM void *pvParameters

#define PAUSE_CPU()       vTaskSuspend(cpuTaskHandle)
#define RESUME_CPU()      vTaskResume(cpuTaskHandle)
#define PAUSE_INFO()       vTaskSuspend(infoTaskHandle)
#define RESUME_INFO()      vTaskResume(infoTaskHandle)
#define PAUSE_SOUND()       vTaskSuspend(soundTaskHandle)
#define RESUME_SOUND()      vTaskResume(soundTaskHandle)
#define PAUSE_SCREEN()    vTaskSuspend(screenTaskHandle)
#define RESUME_SCREEN()   vTaskResume(screenTaskHandle)
#define LOCK_SCREEN()     xSemaphoreTake(screenMutex, portMAX_DELAY)  
#define UNLOCK_SCREEN()   xSemaphoreGive(screenMutex)
#define LOCK_DRAWING()    xSemaphoreTake(usingDrawBuffer, portMAX_DELAY)
#define UNLOCK_DRAWING()  xSemaphoreGive(usingDrawBuffer)
#define SOUND_OFF() GO.Speaker.mute()
#define es_tone(f,d) GO.Speaker.tone(f,d)
#define INFO_RIGHT

#else

#include <Wire.h>
#include <TFT_eSPI.h>
#include "acoos.h"
#define ESPBOY
#ifdef ESPBOY
  #define APSSID "ESPboy"
  #define APHOST "espboy"
  #define APPSK  "87654321"
  #define MCP4725address  0x60
  #define MCP23017address 0
  #define csTFTMCP23017pin 8
  #define LEDquantity     1
  #define LEDPIN         D4
  #define SOUNDPIN       D3

  #include <Adafruit_MCP23017.h>
  #include <Adafruit_MCP4725.h>
  #include <FastLED.h>
#else
  #define APSSID "espico"
  #define APHOST "espico"
  #define APPSK  "87654321"
  #define SOUNDPIN       2
  #define DEBUG_ON_SCREEN
  #define INFO_RIGHT
  #define DISPLAY_X_OFFSET 12 
#endif

#define PAUSE_CPU()
#define RESUME_CPU()
#define PAUSE_INFO()
#define RESUME_INFO()
#define PAUSE_SOUND()
#define RESUME_SOUND()
#define PAUSE_SCREEN()
#define RESUME_SCREEN()
#define LOCK_SCREEN() 
#define UNLOCK_SCREEN()
#define LOCK_DRAWING()
#define UNLOCK_DRAWING()

// #define USE_NUNCHUCK
#ifdef USE_NUNCHUCK
#include <NintendoExtensionCtrl.h>
// Use nunchuck
Nunchuk nchuk;
#endif

#define COOS_TASK_PARAM void
#define SOUND_OFF() digitalWrite(SOUNDPIN, HIGH)
#define es_tone(f,d) tone(SOUNDPIN,f,d)

Coos <5, 0> coos;

ADC_MODE(ADC_VCC);

// Use hardware SPI
TFT_eSPI tft = TFT_eSPI();
#ifdef ESPBOY
Adafruit_MCP23017 mcp;
Adafruit_MCP4725 dac;
CRGB leds[1];
#endif

// ------------------begin ESP8266'centric----------------------------------
#define FREQUENCY    160                  // valid 80, 160
//
#include "ESP8266WiFi.h"
extern "C" {
  #include "user_interface.h"
}
// ------------------end ESP8266'centric------------------------------------

#endif

#define RAM_SIZE 32 * 1024
#define PRG_SIZE 16 * 1024

// RAM LAYOUT (accessible)
// 0
//   PROGRAM INCL VARS
//   Stack Pointer R0 (going down from PRG_SIZE-1)
//   Unused sprite and tile map can be used as PRG space as well
//   but requires you to set the stack pointer at your own PRG-space end
// 16 K
//   SPRITE MAP - 128 8x8 sprites
// 20 K
//   TILE MAP   - 128x32 tiles, can also be used as an additional 128 sprites
// 24 K
//   SCREEN
//
// Available through get/setSpriteFlags:
//   256 bytes SPRITE FLAGS
//   128 bytes LINE_IS_DRAWN
//

int voltaje=0;
uint8_t i2c_adress;
byte thiskey;
byte lastkey;
Ticker timer;
uint16_t cadr_count;
uint16_t rtttl_delay = 0;
int timeCpu = 0,timeGpu = 0,timeSpr = 0,cpuOPS = 0;
byte fps;
volatile uint16_t timers[8] __attribute__ ((aligned));
uint8_t *mem __attribute__ ((aligned));
// static const uint8_t bootseq[] PROGMEM = {0x12,0x00,0x06,0x20,0x61,0x01,0x90,0x00,0x30,0x01,0x11,0x05,0xD4,0x11,0xD0,0x00,0x12,0x01,0x06,0x20,0x61,0x01,0x03,0x01,0x61,0x01,0x12,0x0C,0xC1,0x12,0xC2,0x12,0xB1,0x00,0x92,0x00,0x50,0x00,0x01,0x02,0x52,0x01,0x82,0x02,0x12,0x36,0x82,0x02,0x03,0x02,0x61,0x01,0x82,0x02,0x12,0x18,0x82,0x02,0x12,0x05,0x82,0x02,0x99,0x00,0x48,0x01,0xA8,0xA0,0x99,0x00,0x3E,0x01,0xA8,0x10,0x61,0x01,0x90,0x00,0x16,0x00,0x11,0x0D,0xD4,0x11,0x11,0x02,0xD4,0x51,0x12,0x0C,0x06,0x20,0x61,0x01,0x03,0x01,0x61,0x01,0x12,0x14,0xC1,0x12,0xC2,0x12,0xB1,0x00,0x92,0x00,0x98,0x00,0x01,0x02,0x52,0x01,0x82,0x02,0x12,0x2C,0x82,0x02,0x03,0x02,0x61,0x01,0x82,0x02,0x12,0x18,0x82,0x02,0x12,0x05,0x82,0x02,0x99,0x00,0x48,0x01,0xA8,0xA0,0x99,0x00,0x3E,0x01,0xA8,0x10,0x61,0x01,0x90,0x00,0x5E,0x00,0x11,0x06,0xD4,0x11,0x11,0x03,0xD4,0x51,0x12,0x14,0x06,0x20,0x61,0x01,0x03,0x01,0x61,0x01,0x12,0x1C,0xC1,0x12,0xC2,0x12,0xB1,0x00,0x92,0x00,0xE0,0x00,0x01,0x02,0x52,0x01,0x82,0x02,0x12,0x22,0x82,0x02,0x03,0x02,0x61,0x01,0x82,0x02,0x12,0x18,0x82,0x02,0x12,0x05,0x82,0x02,0x99,0x00,0x48,0x01,0xA8,0xA0,0x99,0x00,0x3E,0x01,0xA8,0x10,0x61,0x01,0x90,0x00,0xA6,0x00,0x11,0x07,0xD4,0x11,0x11,0x04,0xD4,0x51,0x01,0x02,0x52,0x01,0x82,0x02,0x12,0x18,0x82,0x02,0x03,0x02,0x61,0x01,0x82,0x02,0x12,0x18,0x82,0x02,0x12,0x05,0x82,0x02,0x99,0x00,0x48,0x01,0xA8,0xA0,0x12,0x14,0x06,0x20,0x61,0x01,0x03,0x01,0x61,0x01,0x12,0x28,0xC1,0x12,0xC2,0x12,0xB1,0x00,0x92,0x00,0x28,0x01,0x99,0x00,0x3E,0x01,0xA8,0x10,0x61,0x01,0x90,0x00,0x0C,0x01,0x11,0x00,0xD4,0x21,0xD0,0x00,0x9A,0x00,0x01,0x0F,0x00,0x00,0x06,0xF0,0x63,0x01,0x99,0x00,0x0A,0x00,0x50,0x00,0xC2,0x16,0xB1,0x00,0x92,0x00,0x3E,0x01,0x9A,0x00,0x07,0x10,0x12,0x02,0xA0,0x12,0xD4,0xA1,0x9A,0x00,0x00,0x00,0x00,0xE6,0xC9,0x80,0xC8,0xA2,0x10,0x82,0xCA,0x28,0xEC,0x89,0x90};
static const uint8_t bootseq[] PROGMEM = {0x90,0x00,0xa2,0x01,0x11,0x05,0xd4,0x11,0x11,0x00,0xd6,0x01,0xd0,0x00,0x12,0x01,0x06,0x20,0xcf,0x01,0x03,0x01,0xcf,0x01,0xb1,0x0c,0x94,0x00,0x46,0x00,0x01,0x02,0xc0,0x01,0x82,0x02,0x84,0x00,0x36,0x00,0x03,0x02,0xcf,0x01,0x82,0x02,0x84,0x00,0x18,0x00,0x84,0x00,0x05,0x00,0xd4,0xa0,0xa8,0xa0,0x99,0x00,0xb2,0x01,0xa8,0x10,0xcf,0x01,0x90,0x00,0x14,0x00,0x11,0x02,0xd4,0x51,0x11,0x0d,0xd4,0x11,0x12,0x0c,0x06,0x20,0xcf,0x01,0x03,0x01,0xcf,0x01,0xb1,0x14,0x94,0x00,0x86,0x00,0x01,0x02,0xc0,0x01,0x82,0x02,0x84,0x00,0x2b,0x00,0x03,0x02,0xcf,0x01,0x82,0x02,0x84,0x00,0x18,0x00,0x84,0x00,0x05,0x00,0xd4,0xa0,0xa8,0xa0,0x99,0x00,0xb2,0x01,0xa8,0x10,0xcf,0x01,0x90,0x00,0x54,0x00,0x11,0x03,0xd4,0x51,0x11,0x06,0xd4,0x11,0x12,0x14,0x06,0x20,0xcf,0x01,0x03,0x01,0xcf,0x01,0xb1,0x1c,0x94,0x00,0xc6,0x00,0x01,0x02,0xc0,0x01,0x82,0x02,0x84,0x00,0x20,0x00,0x03,0x02,0xcf,0x01,0x82,0x02,0x84,0x00,0x18,0x00,0x84,0x00,0x05,0x00,0xd4,0xa0,0xa8,0xa0,0x99,0x00,0xb2,0x01,0xa8,0x10,0xcf,0x01,0x90,0x00,0x94,0x00,0x11,0x04,0xd4,0x51,0x11,0x07,0xd4,0x11,0x01,0x02,0xc0,0x01,0x82,0x02,0x84,0x00,0x16,0x00,0x03,0x02,0xcf,0x01,0x82,0x02,0x84,0x00,0x18,0x00,0x84,0x00,0x05,0x00,0xd4,0xa0,0xa8,0xa0,0x99,0x00,0xb2,0x01,0x99,0x00,0xb2,0x01,0x99,0x00,0xb2,0x01,0x11,0x0a,0xd4,0x21,0x84,0x00,0x5e,0x00,0x84,0x00,0x28,0x00,0x84,0x00,0x61,0x00,0x84,0x00,0x2b,0x00,0xd0,0x20,0xa8,0x80,0x99,0x00,0xb2,0x01,0x99,0x00,0xb2,0x01,0x99,0x00,0xb2,0x01,0x11,0x08,0xd4,0x21,0x84,0x00,0x62,0x00,0x84,0x00,0x24,0x00,0x84,0x00,0x65,0x00,0x84,0x00,0x27,0x00,0xd0,0x20,0xa8,0x80,0x99,0x00,0xb2,0x01,0x99,0x00,0xb2,0x01,0x99,0x00,0xb2,0x01,0x11,0x0c,0xd4,0x21,0x84,0x00,0x66,0x00,0x84,0x00,0x28,0x00,0x84,0x00,0x69,0x00,0x84,0x00,0x2b,0x00,0xd0,0x20,0xa8,0x80,0x99,0x00,0xb2,0x01,0x99,0x00,0xb2,0x01,0x99,0x00,0xb2,0x01,0x11,0x0b,0xd4,0x21,0x84,0x00,0x62,0x00,0x84,0x00,0x2c,0x00,0x84,0x00,0x65,0x00,0x84,0x00,0x2f,0x00,0xd0,0x20,0xa8,0x80,0x12,0x00,0x06,0x20,0xcf,0x01,0x03,0x01,0xcf,0x01,0xb1,0x0a,0x94,0x00,0x96,0x01,0x99,0x00,0xb2,0x01,0xa8,0x10,0xcf,0x01,0x90,0x00,0x80,0x01,0x11,0x00,0xd4,0x21,0x11,0x01,0xd6,0x01,0xd0,0x00,0x9a,0x00,0x11,0x00,0x01,0x0f,0x00,0x00,0x06,0xf0,0xd1,0x01,0x99,0x00,0x04,0x00,0x50,0x00,0x1f,0x00,0x55,0x0f,0xc2,0xf6,0xbf,0x00,0x92,0x00,0xb6,0x01,0x9a,0x00,0x00,0x00,0x00,0xe6,0xc9,0x80,0xc8,0xa2,0x10,0x82,0xca,0x28,0xec,0x89,0x90};

inline void rebootCPU() {
  memset(mem, 0, RAM_SIZE);
  for(int i = 0; i < sizeof(bootseq); i++){
    // mem[i] = bootseq[i];
    mem[i] = (int8_t)pgm_read_byte_near(bootseq + i);
  }

  cpuInit();  
}

void loadFromSerial(){
  char c;
  // unsigned char n;
  int j = 0;
  memset(mem, 0, RAM_SIZE);
  while(c != '.'){
    if(Serial.available()){
      c = Serial.read();
      Serial.print(c);
      if(c == 'x'){
        char a = Serial.read();
        char b = Serial.read();
        // n = hextobyte(a, b);
        mem[j++] = hextobyte(a, b);
      }
    }
  }
  Serial.print(F("load "));
  Serial.print(j);
  Serial.println(F(" byte"));
  Serial.print(F("free heap "));
  Serial.println(system_get_free_heap_size());
  cpuInit();
}

unsigned long timeC = 0;

void coos_cpu(COOS_TASK_PARAM){   
  while(1){
    COOS_DELAY(0);        // 1 ms
    timeC = millis();
    cpuOPS += cpuRun(1600);   // was 1100 before
    timeCpu += millis() - timeC;
  }
}

unsigned long timeR = 0, timeF = 0;

void coos_screen(COOS_TASK_PARAM){
   while(1){
    yield();
    // timeR = millis();
    // wait 50 ms until new screen redraw
    // timeSpr += millis() - timeR;
    timeR = 33 - timeR;
    if (timeR < 0) timeR = 0;
    COOS_DELAY(33);        // 40 ms
    LOCK_SCREEN();
    timeR = millis();
    // tie key press to screen refresh timing
    getKey();
    // LOCK_DRAWING();
    redrawScreen();
    // UNLOCK_DRAWING();
    timeR = millis() - timeR;
    timeGpu += timeR;
    if(millis() - timeF > 1000){
      timeF = millis();
      fps = cadr_count;
      cadr_count = cadr_count % 2;
    }
    if (thiskey & KEY_START) es_pause();
    UNLOCK_SCREEN();
  } 
}

void timer_tick(void){
  for(int8_t i = 0; i < 8; i++){
    if(timers[i] >= 1)
      timers[i] --;
  }
}

void es_pause(){
  uint8_t prevKey = KEY_START;

  PAUSE_CPU();
  PAUSE_SOUND();
  PAUSE_INFO();
//  drawPause();
//  redrawScreen();
#if defined(INFO_RIGHT)
  tft.fillRect(270, 0, 32, 98, 0x0000);
  tft.setTextColor(0xF809);
  tft.fillRect(270, 10, 4, 10, 0xF809);
  tft.fillRect(276, 10, 4, 10, 0xF809);
#endif
  while(1){
    delay(100);
    getKey();
    if((thiskey & KEY_START) && prevKey != KEY_START){
      thiskey = 0;
      delay(800);
      break;
    }
    if(thiskey & KEY_A){
      while(thiskey & KEY_A){
        delay(100);
        getKey();
      }
      thiskey = 0;
      rebootCPU();
      break;
    }
    if((thiskey & KEY_B) && (prevKey != KEY_B)){
      setRtttlPlay(-1);
      thiskey = 0;
      delay(800);
      break;
    }
    prevKey = thiskey;
  }
  RESUME_INFO();
  RESUME_SOUND();
  RESUME_CPU();
}

void coos_info(COOS_TASK_PARAM){   
  while(1){
    COOS_DELAY(1000);        // 1000 ms
    LOCK_SCREEN();
    // voltaje = ESP.getVcc();
#if defined(INFO_RIGHT)
    tft.fillRect(270, 0, 32, 98, 0x0000);
    tft.setTextColor(0xFFFF);
    tft.setCursor(270, 0);
    tft.println("fps");
    tft.setCursor(270, 10);
    tft.println(fps);
    tft.setCursor(270, 20);
    tft.println("cpu");
    tft.setCursor(270, 30);
    tft.println(timeCpu, DEC);
    tft.setCursor(270, 40);
    tft.println("gpu");
    tft.setCursor(270, 50);
    tft.println(timeGpu, DEC);
    // tft.println("spr");
    // tft.println(timeSpr, DEC);
    tft.setCursor(270, 60);
    tft.println("kIPS");
    tft.setCursor(270, 70);
    tft.println(cpuOPS >> 10, DEC);
#elif defined(INFO_BOTTOM)
    tft.fillRect(0, 232, 320, 8, 0x0000);
    tft.setTextColor(0xFFFF);
    tft.setCursor(12, 232);
    tft.print("fps ");
    tft.print(fps);
    tft.print(" cpu ");
    tft.print(timeCpu, DEC);
    tft.print(" gpu ");
    tft.print(timeGpu, DEC);
    // tft.println("spr");
    // tft.println(timeSpr, DEC);
    tft.print(" kIPS ");
    tft.print(cpuOPS >> 10, DEC);
#endif
    UNLOCK_SCREEN();
    timeCpu = 0;
    timeGpu = 0;
    // timeSpr = 0;
    cpuOPS = 0;
  }
}

void coos_rtttl(COOS_TASK_PARAM){
  while(1){
    rtttl_delay = playRtttl();
    if(rtttl_delay){
      //if(rtttl_delay > 10)
      //  rtttl_delay -= 10;
      COOS_DELAY(rtttl_delay);
    }
    else {
      SOUND_OFF();
      COOS_DELAY(100);
    }
  }
}

void setup() {
  byte menuSelected = 3;

#ifdef _ODROID_GO_H_
  GO.begin();
  GO.Speaker.setVolume(10);
  // GO.Speaker.mute();
  screenMutex = xSemaphoreCreateMutex();
  usingDrawBuffer = xSemaphoreCreateMutex();
#else
  // ------------------begin ESP8266'centric----------------------------------
  WiFi.forceSleepBegin();                  // turn off ESP8266 RF
  delay(1);                                // give RF section time to shutdown
  system_update_cpu_freq(FREQUENCY);
  // ------------------end ESP8266'centric------------------------------------
#ifdef ESPBOY
  Wire.begin();
  Wire.setClock(1000000);
  Serial.println();
  Serial.println(F("ESPboy"));
  scani2c();
  //DAC init
  dac.begin(MCP4725address);
  delay(100);
  dac.setVoltage(0, false);
  //buttons on mcp23017 init
  mcp.begin(MCP23017address);
  delay (100);
  for(int i = 0; i < 8; i++){
     mcp.pinMode(i, INPUT);
     mcp.pullUp(i, HIGH);
  }
  FastLED.addLeds<WS2812B, LEDPIN, RGB>(leds, 1);
  leds[0] = CRGB::Black;
  FastLED.show();
  FastLED.show();
  delay(50);
  //initialize LCD
  mcp.pinMode(csTFTMCP23017pin, OUTPUT);
  mcp.digitalWrite(csTFTMCP23017pin, LOW);
  tft.init();
  tft.setRotation(0);
  //LCD backlit on
  for (int count = 0; count < 1000; count += 50){
    dac.setVoltage(count, false);
    delay(50);
  }
  dac.setVoltage(4095, true);
  delay(1000);
#else
  tft.init();            // initialize LCD
  tft.setRotation(3);
#endif
  tft.fillScreen(0x0000);
  tft.setTextSize(1);
  tft.setTextColor(0xffff);
  Serial.begin (115200);
  //sound init and test
  pinMode(SOUNDPIN, OUTPUT);
  tone(SOUNDPIN, 200, 100);
  delay(100);
  tone(SOUNDPIN, 100, 100);
  delay(100);
  noTone(SOUNDPIN);

#ifdef USE_NUNCHUCK
  nchuk.begin();
  while (!nchuk.connect()) {
    Serial.println("Nunchuk not detected!");
    delay(1000);
  }
#else
  Wire.begin(SDA, SCL);
  geti2cAdress();
  Serial.println(i2c_adress, HEX);
#endif

#endif

  Serial.println();
  //Initialize File System
  if(SPIFFS.begin()){
    Serial.println(F("SPIFFS Initialize....ok"));
    //fileList("/");
  }
  else{
    Serial.println(F("SPIFFS Initialization...failed"));
  }

#ifndef _ODROID_GO_H_
  voltaje = ESP.getVcc();
  randomSeed(ESP.getVcc());

  getKey();
  //go to web file manager
  if(thiskey & KEY_B){//key B
    serverSetup();
    tft.setCursor(0,10);
    tft.print(F("SSID "));
    tft.print(F(APSSID));
    tft.print(F("\nPassword "));
    tft.print(F(APPSK));
    tft.print(F("\nGo to \nhttp://192.168.4.1"));
    tft.print(F("\nin a web browser"));
    tft.print(F("\nPress button A to\nreboot"));
    while(1){
      serverLoop();
      getKey();
      if(Serial.read() == 'r' || thiskey & KEY_A)
        ESP.reset();
      delay(100);
    }
  }
  else{
    WiFi.forceSleepBegin();                  // turn off ESP8266 RF
    delay(1);
  }
#endif

  Serial.println(F("Allocating RAM and initialazing CPU..."));
  memoryAlloc();

  rebootCPU();

  Serial.println(F("Starting cooperative system..."));
  // randomSeed(analogRead(0));
  timer.attach(0.001, timer_tick);
#ifdef _ODROID_GO_H_
  setRtttlPlay(-1);
  xTaskCreate(coos_cpu, "espico cpu", 4096, NULL, 2, &cpuTaskHandle);
  xTaskCreate(coos_rtttl, "espico sound", 1024, NULL, 2, &soundTaskHandle);
  xTaskCreatePinnedToCore(coos_info, "espico info", 4096, NULL, 2, &infoTaskHandle, 0);
  xTaskCreatePinnedToCore(coos_screen, "espico screen", 4096, NULL, 2, &screenTaskHandle, 0);
  // xTaskCreatePinnedToCore(coos_screen, "espico screen", 1024, NULL, 2, NULL, 0);
#else 
  coos.register_task(coos_cpu); 
  coos.register_task(coos_screen);   
//  coos.register_task(coos_key);
  coos.register_task(coos_rtttl); 
  coos.register_task(coos_info);
  coos.start();                     // init registered tasks
#endif
}

void loop() {
#ifdef _ODROID_GO_H_
  COOS_DELAY(100);
#else
  coos.run();  // Coos scheduler
#endif
  if(Serial.available()){
    char c = Serial.read();
    Serial.print(c);
    if(c == 'm'){
      loadFromSerial();
      cpuInit();
      return;
    }
#ifndef _ODROID_GO_H_
    else if(c == 'r'){
      ESP.reset();
      return;
    }
#endif
    else if(c == 'd'){
      debug();
      return;
    }
  }
}
